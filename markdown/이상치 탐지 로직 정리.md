# 이상치 탐지 로직 정리 (Hourly Job)

이 문서는 현재 레포의 **이상치 탐지(anomaly detection) 계산 로직**을 정리한 자료입니다.

- **탐지 엔트리포인트(호출 위치)**: `jobs/hourly_job.py`
- **탐지 로직 본체**: `core/anomaly_detector.py` (`detect_anomalies`)
- **Baseline 조회/재계산**: `core/baseline.py`, `infra/mongo_client.py`
 
---

## 데이터 흐름 (어디서/언제 계산되나)

매 시간 실행되는 `jobs/hourly_job.py`에서 아래 순서로 진행됩니다.

1. Billing API 호출 → `extract_entries`
2. 현재 시점까지 누적 집계 → `aggregate_daily` (서비스별 `DailySummary.expect_amount` 생성)
3. MongoDB에서 서비스별 baseline 조회 → `build_baseline_map` + `get_baseline_data`
4. 이상치 탐지 계산 → `detect_anomalies(...)`
5. 이상치가 있으면:
   - `billing_anomalies` 컬렉션에 upsert 저장
   - `billing_daily` 컬렉션(L1, `pricingType: None`)에 `isAnomaly=True` 마킹
   - syslog 로그 기록(알림/연동용)

---

## 용어/입력값

- **observed**: 현재 시각까지의 누적 관측값  
  - 코드: `observed = summary.expect_amount` (`core/anomaly_detector.py`)
- **baseline.mean / baseline.std**: 과거 일별 데이터로부터 만든 “하루 총합” 기준 통계값  
  - 코드: `core/baseline.py`의 `recompute_baseline`에서 `expectAmount`들을 모아 평균/표준편차 계산

---

## 경우의 수(분기)별 이상치 탐지 계산 로직

아래 분기들이 **순서대로** 적용됩니다.

### 1) 탐지 자체를 스킵하는 케이스 (학습중/무의미 서비스 제외)

다음 조건 중 하나라도 해당하면 **이상치 판정 계산을 아예 하지 않고 스킵**합니다.

- **Baseline이 없음**: `baseline_map.get(key) is None`
- **Baseline 표본 수 부족**: `baseline.sample_count < 20`
- **Baseline 평균 0**: `baseline.mean == 0.0`

> 의도: 표본이 적은 서비스는 “학습중”으로 보고 오탐을 줄이며, mean==0인 경우는 ratio(분모) 관점에서 의미가 없거나 `inf`가 될 수 있어 탐지/저장/마킹을 하지 않습니다.

---

### 2) (2번) 시간 보정을 하지 않고 “하루 총합 baseline”을 그대로 쓰는 케이스

현재 구현은 시간 보정(progress)을 사용하지 않고, baseline 통계를 그대로 기대값으로 사용합니다.

- \(expected\_mean = baseline.mean\)
- \(expected\_std = baseline.std\)

> 의미: “현재 시각까지 누적 observed”를 “하루 총합 baseline”과 비교하는 모니터링**입니다.  
> 보정이 없기 때문에 하루 초반에는 탐지 민감도가 떨어질 수 있고, 대신 특정 서비스(0시에 일괄 반영 등)에서 초반 오탐을 줄이는 효과가 있을 수 있습니다.  
> 또한 매시간 모니터링이므로, **하루 1회(예: 다음날/정오) 탐지보다 더 이른 시점에 2배 초과 같은 “큰 사고”를 감지**해 추가 손실(그 이후 구간)을 줄일 여지가 있습니다. (이미 발생한 비용을 되돌리진 못하지만, 이후 확산을 막는 용도)

---

### 3) “하락(관측값 < 기대값)”은 이상치로 보지 않는 케이스

- 조건: `observed < expected_mean`
- 처리: **스킵**

> 정책적으로 “비용 급증”만 이상치로 보고, 비용이 기대보다 낮은 상황은 이상치에서 제외합니다.

---

### 4) Z-score 계산 케이스

Z-score는 다음과 같이 계산합니다.

- \(z = (observed - expected\_mean) / expected\_std\)

방어 로직:
- `expected_std == 0`이면  
  - `observed == expected_mean` → `z = 0`  
  - 아니면 → `z = inf`

> 참고: `std==0`인 경우에는 Z-score 분모가 0이라 의미가 없거나 `inf`가 될 수 있어, 실제 판정에서는 Z-score를 쓰지 않고 ratio 기준으로만 판단합니다.

---

### 5) Deviation Ratio(배수) 계산 케이스

배수는 다음과 같이 계산합니다.

- \(ratio = observed / expected\_mean\)

방어 로직:
- `expected_mean == 0`이면  
  - `observed == 0` → `ratio = 0`  
  - 아니면 → `ratio = inf`

> 마찬가지로 탐지 루프에서 `baseline.mean == 0.0`을 사전에 스킵하므로, `mean==0` 방어 로직이 일반적으로는 거의 타지 않습니다.

---

### 6) 최종 이상치 판정 케이스: **Z-score OR Ratio**

상승 방향만 남겨둔 상태(3번 분기 통과 후)에서 아래 조건을 **동시에** 만족할 때만 이상치로 봅니다.

- `z_score >= z_threshold` **또는**
- `deviation_ratio >= ratio_threshold`

기본 임계값(현재 코드의 Hourly Job 호출 기준):
- `z_threshold = 3.0`
- `ratio_threshold = 2.0`

---

## 결과 처리 (저장/마킹/후속 영향)

### 1) 이상치 저장: `billing_anomalies` (upsert)

동일 (date, hour, domainId, projectId, serviceId)에 대해 중복 저장을 피하기 위해 `insert_one`이 아니라 **upsert(update_one, upsert=True)**로 저장합니다.

- 관련 코드: `infra/mongo_client.py::insert_anomaly`

---

### 2) 일별 집계 테이블 마킹: `billing_daily.isAnomaly = True` (L1만)

탐지된 이상치는 `billing_daily` 문서에 `isAnomaly=True`로 업데이트합니다.

- **대상은 L1만**: 필터에 `pricingType: None`이 들어가 있음
- 관련 코드: `infra/mongo_client.py::update_daily_anomaly_status`

---

### 3) Baseline 재계산에서 이상치 제외

baseline 재계산(`recompute_baseline`)을 위해 `billing_daily`를 읽어올 때,
이미 `isAnomaly=True`로 마킹된 데이터는 제외합니다.

- 조건: `"isAnomaly": {"$ne": True}`
- 관련 코드: `infra/mongo_client.py::get_all_daily_for_service`

> 즉, 한 번 이상치로 찍힌 날짜의 데이터는 이후 baseline 통계에 들어가지 않아, baseline이 “이상치에 끌려 올라가는” 현상을 줄이려는 설계입니다.

---

## 빠른 체크리스트 (운영에서 흔히 보는 케이스)

- **샘플 수가 20 미만이면**: 탐지 자체가 안 됨(학습중)
- **초반 시간대(progress가 작을 때)**: expected_mean/expected_std가 작아져서 ratio나 z가 민감해질 수 있음  
  - 단, 하락은 제외되고 “상승”만 보기 때문에 급증 상황에 더 민감한 편
- **이상치로 마킹된 날은**: baseline 재계산에서 제외됨


