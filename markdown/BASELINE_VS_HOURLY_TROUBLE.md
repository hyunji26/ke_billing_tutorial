# Baseline vs Hourly 누적값 비교 트러블 정리

## 1. 문제 제기 배경

- **Hourly Job**은 매 시간 Billing API를 호출해서, 당일 기준 비용 데이터를 가져온다.
- 이때 Billing API 응답의 `expectAmount`는 **“해당 일자 0시부터 현재 시점까지의 누적 금액”**으로 해석할 수 있다.
  - 예시 (같은 집계 키, VM 1개라고 가정):
    - 10시: 30,000원
    - 11시: 60,000원
    - 12시: 90,000원
    - …
    - 24시: 240,000원 (하루 총 사용 금액 근처)
- 반면, **Baseline(`billing_baseline`)은 Daily Job이 `billing_daily`를 모아서 만든 “하루 총 사용금액(Daily Sum)” 기준 통계**이다.
  - 즉, `mean`, `std`, `p50`, `p95` 등은 모두 **“하루 전체가 끝났을 때의 총 사용량”**을 기반으로 한다.

현재 구현은 **Hourly Job에서 “지금까지의 누적 금액”을 “하루 총 사용량 Baseline”과 그대로 비교**하고 있다.

## 2. 왜 문제가 되는가? (시점 불일치)

### 2.1. 개념 미스매치

- 10시 시점의 30,000원은 **“하루의 일부(약 10/24 지점)까지 쓴 금액”**이다.
- Baseline의 `mean`은 **“하루가 끝났을 때(24시 기준)의 총 금액”**이다.

즉, 아래와 같은 비교를 하고 있는 셈이다.

- **비교 대상 A (관측값)**: 10시까지 누적된 30,000원
- **비교 대상 B (Baseline)**: 하루가 끝났을 때 보통 나오는 240,000원

이 둘은 **시간 축이 다르기 때문에 직접 비교하면 통계적으로 깨끗하지 않다.**

### 2.2. 실제로 어떤 문제가 생기는가?

- **아침/낮(초반 시점)**:
  - 누적 금액이 아직 작기 때문에, **아주 비정상적으로 많이 써도** Baseline(하루 총합)보다 작게 나오는 경우가 많다.
  - 예:  
    - Baseline mean = 240,000원  
    - 10시 누적 = 80,000원 (평소보다 훨씬 많이 쓴 상황)  
    - 그래도 80,000 < 240,000 이므로, Z-score / Ratio 기준에서 이상치로 안 잡힐 가능성이 크다.
  - 결과: **하루 초반에는 이상치를 놓치는( False Negative ) 구조**가 된다.

- **하루 후반(23~24시)**:
  - 누적 금액이 하루 총합 근처가 되므로 Baseline과의 비교가 타당해진다.
  - 이때는 이상치가 잘 잡히지만, **이미 하루 대부분이 지난 뒤**일 수 있다.

정리하면, **“시점(Progress)에 따라 비교의 의미가 크게 달라지는 설계”**라는 것이 이 트러블의 핵심이다.

## 3. 원칙: 같은 개념끼리 비교해야 한다

이 문제를 풀기 위한 기본 원칙은 단순하다.

> **Baseline과 관측값은 같은 개념(동일한 시간 스케일)을 가리켜야 한다.**

즉, 둘 중 하나를 맞춰줘야 한다.

- 옵션 A: **Baseline을 “현재 시점까지의 예상 누적액”으로 보정**해서 비교
- 옵션 B: **관측값을 “하루 전체로 환산된 예상 총액”으로 변환**해서 비교
- 옵션 C: 애초에 **시간당(Hourly) 사용량 기준 Baseline**을 별도로 구축

## 4. 개선 방안 후보

### 4.1. 진행률(Progress) 보정 방식 (현실적인 개선안)

현재 Baseline은 “하루 총 사용량” 기준이므로, **현재 시각 기준 진행률(Progress)을 곱해서 “지금 시점에 정상이라면 이 정도 누적이 되어 있어야 한다”는 기대값을 만든 뒤 비교**하는 방식이다.

#### 아이디어

- `current_hour`: 현재 시각 (0~23)
- 진행률 \( progress \):  
  \[
  progress = \frac{current\_hour + 1}{24}
  \]
  - 예:  
    - 0시(첫 시간대) → progress ≈ 1/24  
    - 11시 → progress ≈ 12/24 = 0.5  
    - 23시 → progress = 24/24 = 1.0

- Baseline mean이 하루 총액 `baseline.mean`이라면,
  - **지금 시점에서의 “정상적인 누적 기대값”**:
    \[
    expected\_so\_far = baseline.mean \times progress
    \]

- 그 다음, 관측값 `observed`와 `expected_so_far`를 비교해서 Z-score, Ratio를 계산한다.

#### 장점

- Daily Baseline 설계를 그대로 유지하면서, **비교 로직만 손봐서 시점 불일치 문제를 완화**할 수 있다.
- 코드 변경 범위가 작고, 튜토리얼 단계에서 적용하기에 부담이 적다.

#### 단점 / 한계

- “하루 동안 사용량이 선형적으로 늘어난다”는 가정을 깔고 있다.
  - 실제로는 낮/밤 사용 패턴이 다를 수 있다.
  - 예: 낮에만 트래픽이 몰리는 서비스.
- 그럼에도 불구하고, **현재의 “아예 보정이 없는 상태”보다는 훨씬 합리적인 비교**가 된다.

### 4.2. 시간당(Hourly Delta) Baseline 설계 (완성도 높은 안)

보다 이상적인 접근은 **“시간당 사용량” 자체를 Baseline으로 삼는 것**이다.

1. Billing API 응답이 누적인 경우:
   - 각 Hourly Job 실행 시, **이전 스냅샷과의 차이(Δ)**를 구한다.
   - \(\Delta amount = current\_cumulative - previous\_cumulative\)
   - 이렇게 하면 “이번 1시간 동안 얼마를 썼는가?”라는 **진짜 시간당 사용량**이 나온다.

2. Daily Job 또는 별도 배치에서:
   - 과거의 시간당 Δ 값들을 모아서,
   - 시간대별 Baseline (예: 10시 평균, 11시 평균, …)을 계산한다.

3. Hourly Job에서는:
   - 방금 계산한 Δ 값을
   - 같은 시간대의 Baseline(예: “평균 10시 사용량”)과 비교해서 이상치를 판단한다.

#### 장점

- 현실 세계의 사용 패턴(시간대별 차이)을 훨씬 잘 반영할 수 있다.
- “누적 vs 하루 총합” 같은 개념 미스매치가 사라진다.

#### 단점

- 설계와 구현 복잡도가 높아진다.
- Baseline 데이터가 “서비스 × 시간대(0~23)” 조합만큼 늘어난다.
- 튜토리얼 단계에서는 다소 과할 수 있다.

## 5. 현재 튜토리얼에서의 선택

이 튜토리얼의 목표는:

- Kakao Cloud Billing API 연동
- 일/시간 단위 집계 개념 이해
- Baseline & 이상치 탐지 개념 체험
- Slack 알림까지 한 번에 이어지는 **엔드 투 엔드 파이프라인 경험**

이라는 교육용 목적에 가깝다.

따라서 **완벽한 통계 모델**보다는,

- 이해하기 쉬운 구조
- 코드 복잡도가 낮은 구현
- 직관적인 동작 흐름

을 우선시했다.

다만, 이 문서에서 정리한 것처럼:

- **현재 구현은 “하루 총합 Baseline vs 시점별 누적 관측값”이라는 개념 미스매치가 존재**하며,
- 이를 인지하고,
  - 간단히는 **진행률 보정(Progress 보정)**을 추가하거나,
  - 고도화 단계에서는 **시간당 Δ 및 시간대별 Baseline**으로 확장하는 것이 바람직하다.

## 6. 요약

- Hourly Job은 “현재까지의 누적 금액”을 보고, Baseline은 “하루 총 금액”을 기준으로 한다.
- 아무 보정 없이 이 둘을 직접 비교하는 것은, 시점(시간)에 따라 의미가 크게 달라지는 **개념 미스매치**를 야기한다.
- 현실적인 1차 개선안:
  - **Baseline을 현재 시점 진행률로 보정해서 “지금 시점에 정상이라면 이 정도 누적이어야 한다”는 기대값과 비교하는 방식**을 도입한다.
- 보다 이상적인 궁극적 개선안:
  - **시간당 Δ 사용량과 시간대별 Baseline 설계**로 확장한다.

이 트러블은 “시간 스케일을 맞추지 않고 비교하면 어떤 문제가 생기는지”를 잘 보여주는 사례이며,  
향후 실제 운영 환경에 적용할 때 반드시 다시 고민해야 할 설계 포인트이다.




